import java.time.LocalTime;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import io.reactivex.BackpressureStrategy;
import io.reactivex.Flowable;
import io.reactivex.Maybe;
import io.reactivex.Observable;
import io.reactivex.Single;
import io.reactivex.disposables.Disposable;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.subscribers.TestSubscriber;
import io.vertx.reactivex.core.Vertx;
import io.vertx.reactivex.core.eventbus.Message;

import static java.util.stream.Collectors.toList;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {

  private static Observable<Long> fakeUserInput() {
    return Observable.just(3L, 4L, 5L);
  }

  private static Observable<Long> second() {
    return Observable.just(1L, 2L);
  }

  private static Observable<User> user() {
    return Observable.just(new User("iranna", 1), new User("vishwa", 2), new User("yashaswi", 3));
  }

  public static void main(String[] args) throws InterruptedException {

        /*Map<Integer, Function<Integer, String>> caseBlocks = new HashMap<>(2);
        caseBlocks.put(1, (integer) -> "First Odd Number : " + integer);
        caseBlocks.put(2, (integer) -> "First Even Number : " + integer);
        List<Integer> list = Arrays.asList(1, 2, 3, 4);

        Observable.fromIterable(list)
                .lift(new SwitchCase<>(caseBlocks))
                .subscribe(System.out::println);*/

    // zipping is a process get element from both instances
        /*fakeUserInput()
                .zipWith(second().blockingIterable(), (a, b) -> a + b)
                .map(longValue -> String.format("Hello : %s", longValue))
                .subscribe(System.out::println).dispose();*/


/*        perform2(Observable.just(new User("iranna", 1)));
        perform2(Observable.just(new User("vishwa", 2)));
        perform2(Observable.just(new User("yashaswi", 3)));*/

/*
        haandlingMayBe(Maybe.just(new User("iranna", 1)));
        haandlingMayBe(Maybe.empty());
        */

       /* handlingSingle(Single.just(new User("iranna", 1)));
        handlingSingle(Single.just(null));*/

    /* check();*/

        /*threadCheckSubscribeOn(Observable.just(1, 2, 3, 4, 5));
        System.out.println("Completed first calling");

        threadCheckSubscribeOn(Observable.just(1, 2, 3, 4, 5));
        System.out.println("Completed second calling");

        threadCheckSubscribeOn(Observable.just(6, 7, 8, 9, 10));
        System.out.println("Completed second calling");*/
    /*threadCheckObserveOn(Observable.just(1, 2, 3, 4, 5));*/

    //aggregator(Observable.just(1, 2, 3, 4, 5));


    //thenAllValuesAreBufferedAndReceived();

    // whenDropStrategyUsed_thenOnBackpressureDropped();


       /* flowable();
        System.out.println("Completed");*/

    // peekScan(Observable.just(new User("Iranna", 1), new User("Vishwa", 2)));

    // blockingObservableCreation();


    // nonBlockingObservableCreation();

    // multipleObservableFromOne();
    // multipleObservableFromOneShared();

    // errorHandling();


    // checkObservableSendEventForMultipleSubscriber();

    checkHowOperatorsApplied();
    System.out.println("completed blocking");

    Thread.sleep(2000);
  }


  private static void checkObservableSendEventForMultipleSubscriber() throws InterruptedException {
    Vertx vertx = Vertx.vertx();

    Single<String> consume = vertx.rxDeployVerticle("Consume");
    System.out.println("consumer deployed " + consume.blockingGet());

    Observable<Message<Object>> messageObservable =
        vertx.eventBus().rxSend("check", "ping").toObservable().replay().autoConnect();
    System.out.println("first subscriber deployed");
    Disposable subscribe = messageObservable.map(rep -> {
      System.out.println("first subscription got reply " + rep.body().toString());
      return rep.body();
    }).subscribe(
        body -> System.out.println(body.toString()),
        error -> error.printStackTrace()
    );

    System.out.println("before sleeping " + subscribe.isDisposed());
    Thread.sleep(1000);
    System.out.println("After sleeping " + subscribe.isDisposed());
    System.out.println();
    System.out.println("second subscriber deployed");
    messageObservable.map(rep -> {
      System.out.println("second subscription got reply " + rep.body().toString());
      return rep.body();
    }).subscribe(
        body -> System.out.println(body.toString()),
        error -> error.printStackTrace()
    );



  }

  private static void checkHowOperatorsApplied() throws InterruptedException {
    System.out.println("Observable Is a function which connects observer to producer");
    System.out.println("Observable has producer which produces the events");
    System.out.println("And the producer has reference to subscriber and calls the onNext for each value of the subscriber");
    System.out.println("Before calling on next of each subscriber producer applies all the operators 'map, filter etc'");
    System.out.println("1 : Each operator like 'filter', 'map' etc it takes a observable and returns a observable");
    System.out.println(
        "2 : At the end each observable has link to next observable and when we say subscribe our data type will have that link");
    System.out.println(
        "3: if we called filter().map() then in Observable.just(10,20)/arrayObservable has link to filterObservable which in turn has link to map observable 'array -> filter -> map -> then to subscriber onNext'");
    System.out.println(
        "4: Each operator 'filter' registers an observer on source stream and when we call 'map' after filter then it registers Observer for the filtered Observable that's how chaining works");



    System.out
        .println("ECH OPERATOR ON OBSERVABLE IS A OBSERVER AND ALSO RETURNS A OBSERVABLE TO NEXT BELOW OPERATOR OR SUBSCRIBER");
    Observable.just(10, -1)
        .filter(item -> {
          System.out.println("Item ins filter " + item);
          return item > 0;
        })
        .map(item -> {
          System.out.println("Item is map " + item);
          return item + 100;
        })
        .subscribe(
            System.out::println,
            Throwable::printStackTrace,
            () -> System.out.println("complete"),
            sub -> System.out.println("subscribed")
        );

    Thread.sleep(1000);
  }

  private static void errorHandling() {

    /*Observable.interval(100, TimeUnit.MILLISECONDS)
        .subscribe(item -> System.out.println("emitted " + item));*/

    Observable<Integer> just = Observable.just(1, 2, 3, 4, 5, 6);
    just
        .map(item -> {
          if (item == 3) {
            throw new RuntimeException("Item was 3");
          }
          return item;
        })
        .onErrorReturn(er -> 10)
        // .onErrorReturnItem(100)
        .subscribe(
            suc -> System.out.println(suc),
            error -> System.out.println(error.getMessage()),
            () -> System.out.println("done")
        );
  }

  private static void multipleObservableFromOne() throws InterruptedException {
    System.out.println("OBSERVABLES ARE BY DEFAULT UNICAST");
    System.out.println(
        "As by default emiter/creator if observable will be called whenever user subscribes to it, So this creator will be called for every subscription");
    System.out.println(
        "if you have some network call returning this data that moght cause performance issue as the call will be made for every subscription");
    Observable<Object> just = Observable.create(emit -> {
      ExecutorService executorService = Executors.newFixedThreadPool(2);
      executorService.execute(() -> Stream.of(10, 20, 30, 40, 50, 60, 70, 80).forEach(item -> {
        System.out.println("emitting item " + item);
        emit.onNext(item);
      }));
    });

    Observable<Integer> lessThen40 = just
        .map(obj -> (Integer) obj)
        .filter(item -> item < 40)
        .delay(20, TimeUnit.MILLISECONDS)
        .map(item -> {
          System.out.println("first " + item);
          return item;
        });

    Observable<Integer> lessThen60GreaterThen40 = just
        .map(obj -> (Integer) obj)
        .filter(item -> item >= 40 && item < 60)
        .delay(20, TimeUnit.MILLISECONDS)
        .map(item -> {
          System.out.println("second " + item);
          return item;
        });

    Observable<Integer> greaterThenOr60 = just
        .map(obj -> (Integer) obj)
        .filter(item -> item >= 60)
        .delay(20, TimeUnit.MILLISECONDS)
        .map(item -> {
          System.out.println("third " + item);
          return item;
        });


    System.out.println("subscribing first");
    lessThen40.subscribe(System.out::println);
    System.out.println("first one subscribed");
    Thread.sleep(500);
    System.out.println("subscribing second");
    lessThen60GreaterThen40.subscribe(System.out::println);
    System.out.println("second one subscribed");
    Thread.sleep(500);
    System.out.println("subscribing third");
    greaterThenOr60.subscribe(System.out::println);
    System.out.println("third one subscribed");
    Thread.sleep(500);


    just.subscribe(i -> System.out.println("Another subscriber" + i));

    System.out.println("Observable creation is created and emiting the values for every subscription");

  }

  private static void multipleObservableFromOneShared() throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    System.out.println(
        "To avoid calling observable creation code/call every subscription then we should use reply() which give ConnectableObservables or replySubsject");

    System.out.println("Option 1: with ConnectableObservable");
    ConnectableObservable<Object> just = Observable.create(emit -> {
      executorService.execute(() -> Stream.of(10, 20, 30, 40, 50, 60, 70, 80).forEach(item -> {
        System.out.println("emitting item " + item);
        emit.onNext(item);
      }));
    }).replay();

    just.connect();


  /*
   System.out.println("Option 2: ReplaySubscet");
    ReplaySubject<Integer> just = ReplaySubject.create();
    executorService.execute(() -> Stream.of(10, 20, 30, 40, 50, 60, 70, 80).forEach(item -> {
      System.out.println("emitting item " + item);
      just.onNext(item);
    }));*/



    System.out.println(
        "Observable will emit all the values before any subscriptions as the share needs to convert it into ConnectableObservables");

    Observable<Integer> lessThen40 = just
        .map(obj -> (Integer) obj)
        .filter(item -> item < 40)
        .delay(20, TimeUnit.MILLISECONDS)
        .map(item -> {
          System.out.println("first " + item);
          return item;
        });

    Observable<Integer> lessThen60GreaterThen40 = just
        .map(obj -> (Integer) obj)
        .filter(item -> item >= 40 && item < 60)
        .delay(20, TimeUnit.MILLISECONDS)
        .map(item -> {
          System.out.println("second " + item);
          return item;
        });

    Observable<Integer> greaterThenOr60 = just
        .map(obj -> (Integer) obj)
        .filter(item -> item >= 60)
        .delay(20, TimeUnit.MILLISECONDS)
        .map(item -> {
          System.out.println("third " + item);
          return item;
        });


    System.out.println("subscribing first");
    lessThen40.subscribe(System.out::println);
    System.out.println("first one subscribed");
    Thread.sleep(500);
    System.out.println("subscribing second");
    lessThen60GreaterThen40.subscribe(System.out::println);
    System.out.println("second one subscribed");
    Thread.sleep(500);
    System.out.println("subscribing third");
    greaterThenOr60.subscribe(System.out::println);
    System.out.println("third one subscribed");
    Thread.sleep(500);


    just.subscribe(i -> System.out.println("Another subscriber" + i));

    System.out.println("Observable creation is created and emiting the values for every subscription");

  }

  private static void nonBlockingObservableCreation() throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool(2);
    Observable<Integer> objectObservable = Observable.create(emmitter -> executorService.execute(() -> {
      List<Integer> collect = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());
      System.out.println(
          "As the observable creation is moved from the main thread and hand overed to executor then the main thread wont wait for the observable creation");
      for (int i : collect) {
        System.out.println("Blocking all emmites" + i);
        emmitter.onNext(i);
      }

      emmitter.onComplete();
    }));

    Observable<Integer> delay = objectObservable
        .delay(10, TimeUnit.MILLISECONDS);

    System.out.println(
        "As the observable is created and wont be called until we subscribed, So above code should not run until we subscribe");
    Thread.sleep(1000);
    delay
        .map(i -> i + "hello")
        .subscribe(
            i -> System.out.println(i),
            error -> error.printStackTrace(),
            () -> System.out.println("completed"),
            sub -> System.out.println("subscribed")
        );
  }

  private static void blockingObservableCreation() {
    Observable<Integer> objectObservable = Observable.create(emmitter -> {
      List<Integer> collect = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());
      System.out.println(
          "Observable creation is blocking, Once observable created then all higher order functions on observable are non-blocking ");
      for (int i : collect) {
        System.out.println("Blocking all emmites" + i);
        emmitter.onNext(i);
      }

      emmitter.onComplete();
    });

    Observable<Integer> delay = objectObservable
        .delay(10, TimeUnit.MILLISECONDS);

    System.out.println("This is cold observable");
    System.out.println(
        "As the observable is created and wont be called until we subscribed, So above code should not run until we subscribe");

    delay.map(i -> i + "hello")
        .subscribe(
            i -> System.out.println(i),
            error -> error.printStackTrace(),
            () -> System.out.println("completed"),
            sub -> System.out.println("subscribed")
        );

  }

  public static void connectable(Observable<Integer> obs) throws InterruptedException {

    obs.subscribe(e -> System.out.println("first element " + e));
    Thread.sleep(100);
    obs.subscribe(e -> System.out.println("second element " + e));
    Thread.sleep(100);
    obs.subscribe(e -> System.out.println("third element " + e));


    System.out.println("completed observable");

    ConnectableObservable con = obs.publish();

    con.subscribe(e -> System.out.println("first element " + e));
    Thread.sleep(100);
    con.subscribe(e -> System.out.println("second element " + e));
    Thread.sleep(100);
    con.subscribe(e -> System.out.println("third element " + e));

    System.out.println("completed subscribing on connectable");

    con.connect();

  }

  public static void peekScan(Observable<User> obs) {
    String[] letters = {"a", "b", "c"};
    Observable.fromArray(letters)
        .scan(new StringBuilder(), StringBuilder::append)
        .lastElement()

        /*  .map(va -> {
              System.out.println("In map " + va.toString());
              return va;
          })*/
        .subscribe(
            total -> System.out.println("subscribed " + total.toString()),
            error -> error.printStackTrace(),
            () -> System.out.println("completed")/*,
                        sub -> System.out.println("subscribed with " + sub.isDisposed())*/
        );
  }

  public static void flowable() {

    Flowable.fromIterable(IntStream.rangeClosed(1, 20).boxed().collect(toList()))
        //.parallel()
        //.doOnSubscribe(System.out::println)
        .map(v -> v + 10)
        .delay(10, TimeUnit.MILLISECONDS)
        .map(v -> v + 10)
        .subscribe(System.out::println);
  }


  public static void thenAllValuesAreBufferedAndReceived() {
    List<Integer> testList = IntStream.range(0, 100000)
        .boxed()
        .collect(toList());

    Observable observable = Observable.fromIterable(testList);
    TestSubscriber<Integer> testSubscriber = observable
        .toFlowable(BackpressureStrategy.BUFFER)
        .observeOn(Schedulers.computation()).test();

    System.out.println(LocalTime.now());
    List<Integer> receivedInts = testSubscriber.getEvents()
        .get(0)
        .stream()
        .mapToInt(object -> (int) object)
        .boxed()
        .collect(toList());

    System.out.println(testList.size());
    System.out.println(receivedInts.size());

    System.out.println(LocalTime.now());

  }

  public static void whenDropStrategyUsed_thenOnBackpressureDropped() {

    List<Integer> testList = IntStream.range(0, 100000)
        .boxed()
        .collect(toList());

    Observable observable = Observable.fromIterable(testList);
    TestSubscriber<Integer> testSubscriber = observable
        .toFlowable(BackpressureStrategy.DROP)
        .observeOn(Schedulers.computation())
        .test();
    List<Integer> receivedInts = testSubscriber.getEvents()
        .get(0)
        .stream()
        .mapToInt(object -> (int) object)
        .boxed()
        .collect(toList());

    System.out.println(receivedInts.size());
    System.out.println(testList.size());
  }

  public static void aggregator(Observable<Integer> obs) {
    obs
        .count()
        .subscribe(count -> System.out.println(count));

       /* obs.toFlowable(BackpressureStrategy.BUFFER)
                .parallel()
                .map(v -> {
                    System.out.println("value " + v);
                    return v;
                })
                .subscribe();*/
  }

  public static void threadCheckObserveOn(Observable<Integer> observable) {
    Observable<Object> objectObservable = Observable.create(emmiter -> {
      emmiter.onNext(Thread.currentThread().getName());
      emmiter.onComplete();
    });

    objectObservable
        .map(value -> {
          System.out.println("value " + value + " thread is " + Thread.currentThread().getName());
          return value;
        })
        .observeOn(Schedulers.newThread())
        .map(value -> {
          System.out.println("value " + value + " thread is " + Thread.currentThread().getName());
          return value;
        })
        .observeOn(Schedulers.computation())
        .map(v -> {
          System.out.println("value " + v + " thread is " + Thread.currentThread().getName());
          return v;
        })
        .subscribe(
            System.out::println,
            Throwable::printStackTrace,
            () -> System.out.println("comleted"),
            sub -> System.out.println("subscription disposed " + sub.isDisposed())
        );

    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  private static int createItem() {
    System.out.println("Creating item " + Thread.currentThread().getName());
    return 1;
  }

  public static void threadCheckSubscribeOn(Observable<Integer> observable) {
    observable
        .subscribeOn(Schedulers.newThread())
        .subscribeOn(Schedulers.io())
        .map(v -> {
          System.out.println("value " + v + " thread is " + Thread.currentThread().getName());
          return v;
        })
        .subscribe(
            System.out::println,
            Throwable::printStackTrace,
            () -> System.out.println("comleted"),
            sub -> System.out.println("subscription disposed " + sub.isDisposed())
        );

  }

  private static void check() {
    //Some Emission
    Maybe<String> singleSource = Maybe.just("single item");

    singleSource
        .filter(item -> item.length() > 20)
        .subscribe(
            s -> System.out.println("Item received: from singleSource " + s),
            Throwable::printStackTrace,
            () -> System.out.println("Done from SingleSource")
        );

    //no emission
    Maybe<Integer> emptySource = Maybe.empty();
    emptySource.subscribe(
        s -> System.out.println("Item received: from emptySource" + s),
        Throwable::printStackTrace,
        () -> System.out.println("Done from EmptySource")
    );
  }

  private static void handlingSingle(Single<User> single) {

    Single<User> less_then_or_equal = single
        .map(u -> {
          u.setType("less then or equal");
          return u;
        });

    single
        .map(u -> {
          System.out.println(u.getName());
          return u;
        })
        .filter(u -> u.getId() > 1)
        .map(u -> {
          u.setType("greater");
          return u;
        })
        .switchIfEmpty(less_then_or_equal)
        .map(App::doBlocking)
        //.delay(1000, TimeUnit.MILLISECONDS)
        .subscribe(
            onSuccess -> System.out.println(onSuccess.toString()),
            Throwable::printStackTrace
        ).dispose();

  }


  private static void haandlingMayBe(Maybe<User> mayBe) {

    Maybe<User> less_then_or_equal = mayBe.
        map(u -> {
          u.setType("less then or equal");
          return u;
        });
    mayBe
        .map(u -> {
          System.out.println(u.getName());
          return u;
        })
        .filter(u -> u.getId() > 1)
        .map(u -> {
          u.setType("greater");
          return u;
        })
        .switchIfEmpty(less_then_or_equal)
        .map(App::doBlocking)
        //.delay(1000, TimeUnit.MILLISECONDS)
        .subscribe(
            onSuccess -> System.out.println(onSuccess.toString()),
            Throwable::printStackTrace,
            () -> System.out.println("completed")
        ).dispose();

  }

  private static User doBlocking(User u) {
    System.out.println("In blocking started " + LocalTime.now());
    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    System.out.println("In blocking exited  " + LocalTime.now());
    return u;
  }

  private static void perform(Observable<User> user) {

    user
        .map(u -> {
          System.out.println("in first emit " + u.getType());
          return u;
        })
        .filter(u -> u.getId() == 1)
        .map(u -> {
          System.out.println("in first emit after condition " + u.getType());
          return u;
        })
        .map(u -> {
          u.setType("equal");
          return u;
        })

        // second condition
        .switchIfEmpty(user)
        .map(u -> {
          System.out.println("in second emit " + u.getType());
          return u;
        })
        .filter(u -> (u.getId() > 1) && (u.getName().length() > 6))
        .map(u -> {
          System.out.println("in second emit after condition " + u.getType());
          return u;
        })
        .map(u -> {
          u.setType("greater then 1 id and name length greater then 6");
          return u;
        })

        // third condition
        .switchIfEmpty(user)
        .map(u -> {
          System.out.println("in third emit " + u.getType());
          return u;
        })
        .filter(u -> (u.getId() > 1) && (u.getName().length() <= 6))
        .map(u -> {
          u.setType("greater then 1 but length is less then 6");
          return u;
        })
        .map(u -> {
          System.out.println("in third emit after condition " + u.getType());
          return u;
        })
        .subscribe(u -> System.out.println(u.toString()), Throwable::printStackTrace);
  }


  public static void perform2(final Observable<User> user) {
        /*
            if(id == 1){

            }else {
                if (id > 1 and name.length > 6) {

                } else {
                    if ()
                }
        }*/


    Observable<User> firstCondition = user
        .map(u -> {
          System.out.println("in first emit " + u.getType());
          return u;
        })
        .filter(u -> u.getId() == 1)
        .map(u -> {
          System.out.println("in first emit after condition " + u.getType());
          return u;
        })
        .map(u -> {
          u.setType("equal");
          return u;
        });

    Observable<User> secondIf = user
        .map(u -> {
          System.out.println("in second emit " + u.getType());
          return u;
        })
        .filter(u -> (u.getId() > 1) && (u.getName().length() > 6))
        .map(u -> {
          System.out.println("in second emit after condition " + u.getType());
          return u;
        })
        .map(u -> {
          u.setType("greater then 1 id and name length greater then 6");
          return u;
        });

    Observable<User> secondELse = user
        .map(u -> {
          System.out.println("in third emit " + u.getType());
          return u;
        })
        .filter(u -> (u.getId() > 1) && (u.getName().length() <= 6))
        .map(u -> {
          u.setType("greater then 1 but length is less then 6");
          return u;
        })
        .map(u -> {
          System.out.println("in third emit after condition " + u.getType());
          return u;
        });


    Observable<User> secondCondition = secondIf.switchIfEmpty(secondELse);

    firstCondition
        .switchIfEmpty(secondCondition)
        .map(u -> {
          u.setEnd(LocalTime.now());
          return u;
        })
        .subscribe(System.out::println, Throwable::printStackTrace);

  }

  private static class User {
    private final String name;
    private final int id;
    private String type;
    private LocalTime end;

    private User(String name, int id) {
      this.name = name;
      this.id = id;
    }

    public String getName() {
      return name;
    }

    public int getId() {
      return id;
    }

    public String getType() {
      return type;
    }

    public void setType(String type) {
      this.type = type;
    }

    public LocalTime getEnd() {
      return end;
    }

    public void setEnd(LocalTime end) {
      this.end = end;
    }

    @Override
    public String toString() {
      return "User{" +
          "name='" + name + '\'' +
          ", id=" + id +
          ", type='" + type + '\'' +
          ", end=" + end +
          '}';
    }
  }
}
